<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rebel Datapad Codex</title>
<style>
/* Base layout + aesthetic */
* { box-sizing:border-box; margin:0; padding:0; font-family:'OCR A Std','Courier New', monospace; }
body {
  min-height: 100vh;
  background: radial-gradient(ellipse at center, #1E3A8A 0%, #050505 100%);
  color: #a0d8ff;
  padding: 20px;      
  justify-content: center;
  align-items: center;
  cursor: none;
  overflow-y: auto;
}

/* Datapad centered on screen */
#datapad {
  width:900px; height:600px;
  background: url('images/metal_texture.jpg') center/cover no-repeat;
  border:6px solid #333;
  border-radius:25px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 60px rgba(0,255,255,0.05), inset 0 0 20px #000;
  overflow:hidden;
}
#datapad::before {
  content:"";
  position:absolute; inset:0;
  border-radius:25px;
  background: url('images/metal_noise.png') repeat;
  opacity:0.2;
  z-index:0;
}

/* Screen inside datapad */
#screen {
  position:absolute;
  top:40px; left:40px;
  width:820px; height:520px;
  border-radius:15px;
  overflow:hidden;
  box-shadow: inset 0 0 20px rgba(0,255,255,0.2);
  z-index:1;
  animation: glowPulse 3s infinite alternate;
  cursor:none;
}
#screen * { cursor:none; }

/* Add a solid black background so the metal doesn't show through */
#screen::before {
  content: "";
  position: absolute;
  inset: 0;
  background: #000;
  z-index: 0;
}

/* Scrollable inner content with persistent blue overlay */
#screen-inner {
  position: relative;
  height: 100%;
  overflow-y: auto;
  background: radial-gradient(circle at 50% 50%, rgba(10,20,25,0.95) 0%, rgba(5,10,12,0.9) 100%);
  z-index: 2;
}

/* Blue overlay effects (stays during scroll) */
#blueBase {
  position: fixed;
  top: 40px;
  left: 40px;
  width: 820px;
  height: 520px;
  background-color: rgba(0,255,255,0.35);
  pointer-events:none;
  z-index: 1;
  mix-blend-mode: screen;
}
#blueBase::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background: repeating-linear-gradient(0deg, rgba(0,255,255,0.05) 0px, rgba(0,255,255,0.05) 1px, transparent 2px, transparent 3px);
  opacity: 0.3;
  animation: staticNoise 0.2s steps(2) infinite;
  z-index:2;
}

/* Flicker & scanline */
#flicker {
  position:absolute; inset:0;
  background: repeating-linear-gradient(0deg, rgba(0,255,255,0.15) 0px, rgba(0,255,255,0.15) 1px, transparent 2px, transparent 3px);
  pointer-events:none;
  z-index:6;
  opacity:0;
}
#screen::after {
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  background: repeating-linear-gradient(to bottom, rgba(0,255,255,0.03) 0px, rgba(0,255,255,0.03) 1px, transparent 2px, transparent 3px);
  animation: scanlines 1s linear infinite;
  z-index:7;
}
@keyframes scanlines { 0% { background-position: 0 0; } 100% { background-position: 0 4px; } }

#distortion {
  position:absolute;
  inset:0;
  background: radial-gradient(circle at var(--x,50%) var(--y,50%), rgba(0,255,255,0.18) 0%, transparent 40%);
  pointer-events:none;
  z-index:5;
}

/* Glow pulse animation */
@keyframes glowPulse { 0% { box-shadow: inset 0 0 20px rgba(0,255,255,0.15); } 50% { box-shadow: inset 0 0 35px rgba(0,255,255,0.3); } 100% { box-shadow: inset 0 0 25px rgba(0,255,255,0.2); } }
@keyframes staticNoise { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

/* Layout: sidebar & main content */
#content { display:flex; height:100%; position:relative; z-index:0; }
#sidebar {
  width:200px; background:rgba(5,15,20,0.8); border-right:1px solid #033;
  display:flex; flex-direction:column; padding:15px; gap:6px;
  z-index:2;
}
#sidebar h2 { color:#33cfff; text-align:center; margin-bottom:6px; }
.category-btn {
  background:#0a1f26; border:none; padding:8px; color:#33cfff;
  cursor:pointer; text-align:left; border-left:4px solid #0a5266;
  transition: all 0.14s;
}
.category-btn:hover { background:#0e2a34; border-left-color:#66f0ff; }
.category-btn.active { border-left-color:#00ffff; background:#0e2a34; }
#search { margin-top:auto; padding:6px; background:#0b1c23; border:1px solid #33cfff; color:#a0d8ff; }

#main { flex:1; padding:20px; overflow-y:auto; position:relative; z-index:0; }
#breadcrumbs { margin-bottom:10px; font-size:14px; color:#33cfff; display:flex; gap:6px; align-items:center; }
#breadcrumbs span { cursor: pointer; }
#entryContent h1 { font-size:22px; margin-bottom:10px; color:#66f0ff; position:relative; z-index:0; }
#entryContent img { display:block; margin:10px auto; max-width:100%; max-height:300px; border:2px solid #33cfff; border-radius:4px; box-shadow:0 0 15px rgba(0,255,255,0.3); position:relative; z-index:0; }
#entryContent p { font-size:15px; line-height:1.5em; position:relative; z-index:0; white-space:pre-wrap; }

/* Entry list button coloring indicators */
.entry-row { display:flex; align-items:center; gap:8px; margin:6px 0; }
.entry-title {
  flex:1;
  background:#0a1f26; border:none; padding:8px; color:#a0d8ff; text-align:left; cursor:pointer; border-left:6px solid #0a5266;
  border-radius:4px;
}
.entry-title.locked { border-left-color:#777; color:#777; }       
.entry-title.gm-locked { border-left-color:#ffcc33; color:#ffffcc; } 
.entry-title.unlocked { border-left-color:#0f0; color:#bfffdc; }

.unlock-btn {
  padding:6px 8px; border:none; border-radius:4px; cursor:pointer;
  background:#003; color:#66ffff;
}
.unlock-btn.remove { background:#700; color:#ffc; }

#gmIndicator {
  position:absolute;
  top:10px;
  left:12px;
  background: rgba(0,0,0,0.45);
  color:#66ffff;
  font-size:12px;
  font-weight:700;
  padding:4px 8px;
  border-radius:6px;
  z-index:8;
  pointer-events:none;
  opacity:0;
  transition: opacity 0.16s ease;
}
#gmIndicator.active { opacity:1; }

/* cursor dot and indicators */
.indicator { position:absolute; width:12px; height:12px; border-radius:50%; background:#0f0; box-shadow:0 0 8px #0f0; }
.indicator.red { background:#f00; box-shadow:0 0 8px #f00; }
.indicator:nth-child(1){ top:10px; left:10px; }
.indicator:nth-child(2){ top:10px; right:10px; }
.indicator:nth-child(3){ bottom:10px; left:10px; }
.indicator:nth-child(4){ bottom:10px; right:10px; }
#cursor-dot { position:absolute; width:12px; height:12px; border-radius:50%; background: rgba(0,255,255,0.8); box-shadow:0 0 8px rgba(0,255,255,0.8), 0 0 15px rgba(0,255,255,0.5); pointer-events:none; transform: translate(-50%, -50%); z-index:3; }
#dotFlicker { position:absolute; inset:0; pointer-events:none; z-index:4; }
.dot { position:absolute; width:2px; height:2px; border-radius:50%; background: rgba(0,255,255,0.6); box-shadow:0 0 4px rgba(0,255,255,0.8); pointer-events:none; }

/* small responsive tweak */
@media (max-width:960px){ #datapad{ transform: scale(0.92); } }
</style>


</head>
<body>
<div id="datapad">
  <div class="indicator"></div>
  <div class="indicator red"></div>
  <div class="indicator red"></div>
  <div class="indicator"></div>

  <div id="screen">
    <div id="flicker"></div>
    <div id="distortion"></div>

    <div id="content">
      <div id="sidebar">
        <h2>Codex</h2>
        <button id="homeBtn" class="category-btn">Home</button>
        <button class="category-btn" data-category="planets">Planets</button>
        <button class="category-btn" data-category="characters">Characters</button>
        <button class="category-btn" data-category="technology">Technology</button>
        <button class="category-btn" data-category="items">Items</button>
        <button class="category-btn" data-category="factions">Factions</button>
        <button class="category-btn" data-category="missions">Missions</button>
        <input type="text" id="search" placeholder="Search...">
      </div>

      <div id="main">
        <div id="breadcrumbs"></div>
        <div id="entryContent">
          <h1>Rebel Alliance Field Codex</h1>
          <p>Entries are not loaded until a category is selected. Click a category on the left to begin.</p>
        </div>
        <div id="blueBase"></div>
      </div>
    </div>

    <div id="dotFlicker"></div>
    <div id="cursor-dot"></div>
    <div id="gmIndicator">GM</div>
  </div>
</div>

<script>
/* Full functionality:
   - categories mapped to entries/<category>/manifest.json (manifest is an array of filenames)
   - each entry: entries/<category>/<file>.json expected
   - GM Mode toggled with Ctrl+Shift+G (hidden), unlocks persist via localStorage
   - search + breadcrumbs + visuals preserved
*/

document.addEventListener('DOMContentLoaded', () => {
  const categories = ['planets','characters','technology','items','factions','missions'];
  const entryContent = document.getElementById('entryContent');
  const breadcrumbs = document.getElementById('breadcrumbs');
  const categoryBtns = document.querySelectorAll('.category-btn');
  const searchInput = document.getElementById('search');
  const homeBtn = document.getElementById('homeBtn');
  const flicker = document.getElementById('flicker');
  const distortion = document.getElementById('distortion');
  const screen = document.getElementById('screen');
  const cursorDot = document.getElementById('cursor-dot');
  const dotFlicker = document.getElementById('dotFlicker');
  const gmIndicator = document.getElementById('gmIndicator');

  let activeCategory = null;
  let activeEntry = null;
  let isGM = false;
  // cache loaded entries per category to avoid refetching unless user wants to refresh
  const cache = {};

  // helper localStorage key
  const lsKey = id => `entry_unlocked__${id}`;

  // utility: safe fetch JSON or null
  async function fetchJson(path) {
    try {
      const r = await fetch(path, { cache: "no-cache" });
      if (!r.ok) return null;
      return await r.json();
    } catch (e) {
      console.error('fetch error', path, e);
      return null;
    }
  }

  // load manifest (simple array) and then each entry JSON
  async function loadCategoryEntries(category) {
    // return cached if present
    if (cache[category]) return cache[category];

    const manifestPath = `entries/${category}/manifest.json`;
    const files = await fetchJson(manifestPath);
    if (!Array.isArray(files)) {
      console.warn('manifest missing or invalid for', category, manifestPath);
      cache[category] = [];
      return [];
    }

    const entries = [];
    for (const file of files) {
      const filePath = `entries/${category}/${file}`;
      const data = await fetchJson(filePath);
      if (!data) {
        console.warn('failed to load entry', filePath);
        continue;
      }
      // ensure id exists (use filename if not)
      if (!data.id) {
        // strip extension from file
        data.id = file.replace(/\.[^/.]+$/, "");
      }
      // attach category
      data.category = category;
      entries.push(data);
    }
    cache[category] = entries;
    return entries;
  }

  // helpers for breadcrumbs
  function updateBreadcrumbs() {
    breadcrumbs.innerHTML = '';
    if (!activeCategory) return;
    const catSpan = document.createElement('span');
    catSpan.textContent = activeCategory.charAt(0).toUpperCase() + activeCategory.slice(1);
    catSpan.addEventListener('click', ()=> { activeEntry = null; renderListForActiveCategory(); });
    breadcrumbs.appendChild(catSpan);
    if (activeEntry) {
      const sep = document.createElement('span'); sep.textContent = ' > ';
      const entrySpan = document.createElement('span'); entrySpan.textContent = activeEntry.name;
      breadcrumbs.appendChild(sep); breadcrumbs.appendChild(entrySpan);
    }
  }

  // render list for active category (with search and GM visibility)
  async function renderListForActiveCategory() {
    entryContent.innerHTML = '';
    if (!activeCategory) {
      entryContent.innerHTML = `<h1>Rebel Alliance Field Codex</h1>
        <p>Entries are not loaded until a category is selected. Click a category on the left to begin.</p>`;
      updateBreadcrumbs();
      return;
    }

    const entries = await loadCategoryEntries(activeCategory);
    const q = (searchInput.value || '').trim().toLowerCase();

    // list container
    const list = document.createElement('div');

    for (const entry of entries) {
      // determine unlocked state; for non-gmMode entries, unlocked by default
      const isGMOnly = Boolean(entry.gmMode);
      const unlocked = isGMOnly ? (localStorage.getItem(lsKey(entry.id)) === "true") : true;

      // if not unlocked for player and not in GM Mode, hide
      if (!unlocked && !isGM) continue;

      // apply search filter
      if (q && !entry.name.toLowerCase().includes(q) && !(entry.description || '').toLowerCase().includes(q)) continue;

      // create row
      const row = document.createElement('div');
      row.className = 'entry-row';

      const titleBtn = document.createElement('button');
      titleBtn.className = 'entry-title';
      titleBtn.textContent = entry.name;

      // color / classes
      if (unlocked) titleBtn.classList.add('unlocked');
      else if (isGM) titleBtn.classList.add('gm-locked');
      else titleBtn.classList.add('locked');

      titleBtn.addEventListener('click', () => {
        activeEntry = entry;
        renderEntryDetail(entry);
      });

      row.appendChild(titleBtn);

      // GM controls: Add/Remove only visible when GM Mode is ON and entry marked gmMode
      if (isGM && isGMOnly) {
        const btn = document.createElement('button');
        btn.className = 'unlock-btn ' + (unlocked ? 'remove' : 'add');
        btn.textContent = unlocked ? 'Remove' : 'Add';
        btn.title = unlocked ? 'Remove from player view' : 'Add to player view';
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (localStorage.getItem(lsKey(entry.id)) === "true") {
            localStorage.removeItem(lsKey(entry.id));
          } else {
            localStorage.setItem(lsKey(entry.id), "true");
          }
          // re-render list to show updated state
          renderListForActiveCategory();
        });
        row.appendChild(btn);
      }

      list.appendChild(row);
    }

    // if nothing to show
    if (!list.childElementCount) {
      const msg = document.createElement('p');
      msg.textContent = isGM ? 'No entries match the current filter.' : 'No entries available (locked or none).';
      entryContent.appendChild(msg);
    } else {
      entryContent.appendChild(list);
    }
    updateBreadcrumbs();
  }

  // render a single entry detail
  function renderEntryDetail(entry) {
    entryContent.innerHTML = '';
    const title = document.createElement('h1');
    title.textContent = entry.name;
    entryContent.appendChild(title);

    if (entry.image) {
      const img = document.createElement('img');
      img.src = entry.image;
      img.alt = entry.name;
      entryContent.appendChild(img);
    }

    const p = document.createElement('p');
    p.textContent = entry.description || '';
    entryContent.appendChild(p);

    // GM mode lock/unlock control inside detail
    if (isGM && entry.gmMode) {
      const unlocked = localStorage.getItem(lsKey(entry.id)) === "true";
      const gmBtn = document.createElement('button');
      gmBtn.className = 'unlock-btn ' + (unlocked ? 'remove' : 'add');
      gmBtn.textContent = unlocked ? 'Remove' : 'Add';
      gmBtn.style.marginTop = '10px';
      gmBtn.addEventListener('click', () => {
        if (unlocked) localStorage.removeItem(lsKey(entry.id));
        else localStorage.setItem(lsKey(entry.id), "true");
        // After changing unlock state, return to list so GM can see effect
        renderListForActiveCategory();
      });
      entryContent.appendChild(gmBtn);
    }

    // Back button
    const back = document.createElement('button');
    back.className = 'category-btn';
    back.textContent = 'Back';
    back.style.marginTop = '12px';
    back.addEventListener('click', () => { activeEntry = null; renderListForActiveCategory(); });
    entryContent.appendChild(back);

    updateBreadcrumbs();
  }

  // Category button wiring
  categoryBtns.forEach(btn => {
    // skip Home special-case
    if (btn.id === 'homeBtn') return;
    btn.addEventListener('click', async () => {
      // find category
      const cat = btn.dataset.category;
      if (!categories.includes(cat)) {
        console.warn('unknown category', cat);
        return;
      }
      // UI active state
      categoryBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      activeCategory = cat;
      activeEntry = null;

      // load entries for category and render
      await loadCategoryEntries(cat);
      renderListForActiveCategory();
    });
  });

  // Home button
  homeBtn.addEventListener('click', () => {
    categoryBtns.forEach(b => b.classList.remove('active'));
    activeCategory = null;
    activeEntry = null;
    searchInput.value = '';
    entryContent.innerHTML = `<h1>Rebel Alliance Field Codex</h1>
      <p>Entries are not loaded until a category is selected. Click a category on the left to begin.</p>`;
    breadcrumbs.innerHTML = '';
  });

  // Search handler (filters current category list)
  searchInput.addEventListener('input', () => {
    // only re-render if a category is active
    if (activeCategory) renderListForActiveCategory();
  });

  // GM Mode toggle: Ctrl+Shift+G (hidden to players)
  document.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'g') {
      isGM = !isGM;
      gmIndicator.classList.toggle('active', isGM);
      // rerender current view so GM-only controls appear/disappear
      if (activeCategory) renderListForActiveCategory();
      else {
        // update breadcrumbs / header state if necessary
        renderListForActiveCategory();
      }
      // small console feedback
      console.log('GM Mode', isGM ? 'ON' : 'OFF');
    }
  });

  // Flicker
  function randomFlicker() {
    if (Math.random() < 0.4) {
      flicker.style.opacity = (0.08 + Math.random() * 0.32).toFixed(2);
      setTimeout(()=> { flicker.style.opacity = 0; }, 50 + Math.random()*180);
    }
  }
  setInterval(randomFlicker, 80);

  // Distortion nudge
  function randomDistortion() {
    if (Math.random() < 0.06) {
      const x = (Math.random()*10 - 5).toFixed(1);
      const y = (Math.random()*10 - 5).toFixed(1);
      distortion.style.transform = `translate(${x}px, ${y}px)`;
      setTimeout(()=> distortion.style.transform = 'translate(0,0)', 60 + Math.random()*140);
    }
  }
  setInterval(randomDistortion, 120);

  // cursor dot
  screen.addEventListener('mousemove', (e) => {
    const r = screen.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    cursorDot.style.left = x + 'px';
    cursorDot.style.top = y + 'px';
  });

  // dot flicker overlay
  function createRandomDot() {
    const d = document.createElement('div');
    d.className = 'dot';
    d.style.left = Math.random()*100 + '%';
    d.style.top = Math.random()*100 + '%';
    dotFlicker.appendChild(d);
    setTimeout(()=> d.remove(), 120 + Math.random()*220);
  }
  setInterval(()=> { if (Math.random() < 0.28) createRandomDot(); }, 55);

  // initial clean state (no category loaded)
  homeBtn.click(); // sets initial UI state
});
</script>
</body>
</html>
