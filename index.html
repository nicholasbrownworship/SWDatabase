<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rebel Datapad Codex — Test (GM Enabled)</title>
<style>
/* ====== CORE STYLING ====== */
* { box-sizing:border-box; margin:0; padding:0; font-family:'OCR A Std','Courier New', monospace; }
body {
  background: radial-gradient(ellipse at center, #050505 0%, #000 100%);
  color:#a0d8ff;
  height:100vh; display:flex; justify-content:center; align-items:center;
  overflow:hidden;
}
#datapad {
  width:900px; height:600px;
  background: url('images/metal_texture.jpg') center/cover no-repeat;
  border:6px solid #333;
  border-radius:25px;
  position:relative;
  box-shadow: 0 0 60px rgba(0,255,255,0.05), inset 0 0 20px #000;
  overflow:hidden;
}
#datapad::before {
  content:"";
  position:absolute; inset:0;
  border-radius:25px;
  background: url('images/metal_noise.png') repeat;
  opacity:0.18;
  z-index:0;
}

/* ====== SCREEN & EFFECTS ====== */
#screen {
  position:absolute;
  top:40px; left:40px;
  width:820px; height:520px;
  background:radial-gradient(circle at 50% 50%, rgba(10,20,25,0.96) 0%, rgba(5,10,12,0.92) 100%);
  border-radius:15px;
  overflow:hidden;
  box-shadow: inset 0 0 20px rgba(0,255,255,0.18);
  z-index:1;
  animation: glowPulse 3s infinite alternate;
}
@keyframes glowPulse {
  0% { box-shadow: inset 0 0 20px rgba(0,255,255,0.12); }
  50% { box-shadow: inset 0 0 35px rgba(0,255,255,0.26); }
  100% { box-shadow: inset 0 0 25px rgba(0,255,255,0.16); }
}

/* Effects layers — visual only, no interaction */
#flicker,
#distortion,
#blueBase,
#dotFlicker,
#cursor-dot {
  pointer-events: none !important;
}

#flicker { position:absolute; inset:0; background: repeating-linear-gradient(0deg, rgba(0,255,255,0.12) 0px, rgba(0,255,255,0.12) 1px, transparent 2px, transparent 3px); z-index:6; opacity:0; }
#screen::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient(to bottom, rgba(0,255,255,0.03) 0px, rgba(0,255,255,0.03) 1px, transparent 2px, transparent 3px); animation: scanlines 1s linear infinite; z-index:7; }
@keyframes scanlines { 0% { background-position: 0 0; } 100% { background-position: 0 4px; } }

#distortion { position:absolute; inset:0; background: radial-gradient(circle at var(--x,50%) var(--y,50%), rgba(0,255,255,0.18) 0%, transparent 40%); z-index:5; }
#blueBase { position:absolute; inset:0; background-color: rgba(0,255,255,0.18); z-index:1; mix-blend-mode: screen; }
#blueBase::after { content: ""; position: absolute; inset: 0; background: repeating-linear-gradient(0deg, rgba(0,255,255,0.04) 0px, rgba(0,255,255,0.04) 1px, transparent 2px, transparent 3px); opacity: 0.25; animation: staticNoise 0.2s steps(2) infinite; z-index:2; }
@keyframes staticNoise { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

/* ====== MAIN CONTENT ====== */
#content {
  display:flex;
  height:100%;
  position:relative;
  z-index:10; /* ensures sidebar is clickable */
}

#sidebar {
  width:200px;
  background:rgba(5,15,20,0.84);
  border-right:1px solid #033;
  display:flex;
  flex-direction:column;
  padding:15px;
  gap:8px;
}
#sidebar h2 { color:#33cfff; text-align:center; margin-bottom:6px; }

.category-btn {
  background:#0a1f26;
  border:none;
  padding:8px;
  color:#33cfff;
  text-align:left;
  border-left:4px solid #0a5266;
  cursor:pointer;
  border-radius:6px;
}
.category-btn:hover { background:#0e2a34; border-left-color:#66f0ff; }
.category-btn.active { border-left-color:#00ffff; background:#0e2a34; }

#search {
  margin-top:auto;
  padding:8px;
  background:#07131a;
  border:1px solid #113844;
  color:#a0d8ff;
  border-radius:6px;
  outline:none;
}

#main { flex:1; padding:18px; overflow-y:auto; position:relative; }
#breadcrumbs { margin-bottom:12px; font-size:14px; color:#33cfff; display:flex; gap:8px; align-items:center; }
#breadcrumbs span { cursor:pointer; text-decoration:underline; }

#entryContent h1 { font-size:22px; margin-bottom:10px; color:#66f0ff; }
#entryContent img { display:block; margin:10px auto; max-width:100%; max-height:320px; border:2px solid #33cfff; border-radius:6px; box-shadow:0 0 18px rgba(0,255,255,0.2); }
#entryContent p { font-size:15px; line-height:1.6em; white-space:pre-wrap; color:#dff6ff; }

/* Entry buttons */
.entry-row { display:flex; align-items:center; gap:8px; margin:8px 0; }
.entry-title {
  flex:1; background:#081a20; border:none; padding:8px; color:#a0d8ff;
  text-align:left; cursor:pointer;
  border-left:6px solid #0a5266; border-radius:6px; font-size:15px;
}
.entry-title.locked { border-left-color:#777; color:#777; }
.entry-title.gm-locked { border-left-color:#ffcc33; color:#ffffcc; }
.entry-title.unlocked { border-left-color:#0f0; color:#bfffdc; }

.unlock-btn { padding:6px 10px; border:none; border-radius:6px; cursor:pointer; background:#003; color:#66ffff; }
.unlock-btn.remove { background:#700; color:#ffc; }

/* GM indicator + lights */
#gmIndicator {
  position:absolute; top:12px; left:20px;
  background: rgba(0,0,0,0.55);
  color:#66ffff; font-size:12px; font-weight:700;
  padding:6px 10px; border-radius:6px; z-index:8;
  pointer-events:none; opacity:0; transition:opacity .16s;
}
#gmIndicator.active { opacity:1; }

.corner-lights { position:absolute; top:12px; right:12px; display:flex; gap:8px; z-index:9; pointer-events:none; }
.corner { width:12px; height:12px; border-radius:50%; box-shadow: 0 0 8px rgba(255,255,255,0.03); }
.corner.tl { position:absolute; top:12px; left:12px; background:#00aaff; box-shadow:0 0 8px #00aaff; }
.corner.tr { background:#ff4444; box-shadow:0 0 8px #ff4444; right:12px; top:12px; position:absolute; }
.corner.bl { position:absolute; bottom:12px; left:12px; background:#9a00ff; box-shadow:0 0 8px #9a00ff; }
.corner.br { position:absolute; bottom:12px; right:12px; background:#ff8c00; box-shadow:0 0 8px #ff8c00; }

#syncInfo {
  position:absolute; right:18px; top:36px; z-index:9; color:#bfeffb; font-size:12px; opacity:0.9;
  text-shadow: 0 0 4px rgba(0,0,0,0.6);
}

#cursor-dot { position:absolute; width:12px; height:12px; border-radius:50%; background: rgba(0,255,255,0.84); box-shadow:0 0 8px rgba(0,255,255,0.8), 0 0 15px rgba(0,255,255,0.35); pointer-events:none; transform:translate(-50%,-50%); z-index:7; }
#dotFlicker { position:absolute; inset:0; z-index:6; }
.dot { position:absolute; width:2px; height:2px; border-radius:50%; background: rgba(0,255,255,0.6); box-shadow:0 0 4px rgba(0,255,255,0.8); pointer-events:none; }

.controls-row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
.gm-tools { margin-left:auto; display:flex; gap:6px; }
.gm-button { background:#033; color:#8ff; border:none; padding:6px 8px; border-radius:6px; cursor:pointer; }
.gm-button:active{ transform: translateY(1px); }
.gm-button.remove { background:#700; color:#ffc; }

#gmEditor {
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  width:680px; background:rgba(0,0,0,0.85); border:1px solid #0a3b45; padding:14px; border-radius:8px;
  z-index:30; box-shadow:0 10px 60px rgba(0,0,0,0.8);
}
#gmEditor input[type="text"], #gmEditor textarea {
  width:100%; padding:8px; background:#07131a; border:1px solid #113844; color:#dff6ff; border-radius:6px;
}
#gmEditor label { display:block; margin-top:8px; color:#66f0ff; font-size:13px; }
#gmEditor .row { display:flex; gap:8px; margin-top:8px; }
#gmEditor .row > div { flex:1; }

/* small helpers */
.kv { color:#9ff; font-size:12px; }
@keyframes blink { from { opacity: 1; } to { opacity: 0.4; } }

@media (max-width:960px) {
  #datapad { transform: scale(0.92); }
  #cursor-dot { display:none; }
  #gmEditor { width:92%; }
}
</style>
</head>
<body>
<div id="datapad">
  <div id="screen">
    <div id="flicker"></div>
    <div id="distortion"></div>
    <div id="blueBase"></div>

    <div id="content">
      <div id="sidebar">
        <h2>Codex</h2>
        <button id="homeBtn" class="category-btn">Home</button>
        <button class="category-btn" data-category="planets">Planets</button>
        <button class="category-btn" data-category="characters">Characters</button>
        <button class="category-btn" data-category="technology">Technology</button>
        <button class="category-btn" data-category="items">Items</button>
        <button class="category-btn" data-category="factions">Factions</button>
        <button class="category-btn" data-category="missions">Missions</button>
        <input type="text" id="search" placeholder="Search...">
      </div>

      <div id="main">
        <div class="controls-row">
          <div id="breadcrumbs"></div>
          <div class="gm-tools" id="gmTools" style="display:none;">
            <button class="gm-button" id="addEntryBtn" title="Add a new entry">+ Add Entry</button>
            <button class="gm-button" id="exportBtn" title="Download unlocked.json">Export unlocked.json</button>
            <button class="gm-button" id="copyBtn" title="Copy unlocked.json">Copy JSON</button>
            <button class="gm-button remove" id="resetLocalBtn" title="Reset local unlocked state">Reset Local</button>
          </div>
        </div>

        <div id="entryContent">
          <h1>Rebel Alliance Field Codex</h1>
          <p>Entries are not loaded until a category is selected. Click a category on the left to begin.</p>
        </div>
      </div>
    </div>

    <div id="dotFlicker"></div>
    <div id="cursor-dot"></div>

    <div id="gmIndicator">GM</div>
    <div class="corner-lights">
      <div class="corner tl"></div>
      <div id="statusCorner" class="corner tr"></div>
      <div class="corner bl"></div>
      <div class="corner br"></div>
    </div>
    <div id="syncInfo">Local only</div>
    <div class="debug-panel" id="debugPanel" style="display:none;">debug</div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const STORAGE_ENTRIES = 'codex_entries_v1';
  const STORAGE_UNLOCKED = 'codex_unlocked_v1';
  const categories = ['planets','characters','technology','items','factions','missions'];

  // DOM refs
  const categoryBtns = Array.from(document.querySelectorAll('.category-btn'));
  const searchInput = document.getElementById('search');
  const homeBtn = document.getElementById('homeBtn');
  const entryContent = document.getElementById('entryContent');
  const breadcrumbs = document.getElementById('breadcrumbs');
  const gmIndicator = document.getElementById('gmIndicator');
  const statusCorner = document.getElementById('statusCorner');
  const syncInfo = document.getElementById('syncInfo');
  const cursorDot = document.getElementById('cursor-dot');
  const dotFlicker = document.getElementById('dotFlicker');
  const gmTools = document.getElementById('gmTools');
  const exportBtn = document.getElementById('exportBtn');
  const copyBtn = document.getElementById('copyBtn');
  const resetLocalBtn = document.getElementById('resetLocalBtn');
  const addEntryBtn = document.getElementById('addEntryBtn');
  const debugPanel = document.getElementById('debugPanel');
  const distortion = document.getElementById('distortion');

  // app state
  let activeCategory = null;
  let activeEntryId = null;
  let isGM = false;
  let entriesByCategory = {};
  let unlockedByCategory = {}; // internal: { category: { id: true } }

  // --- Utilities ---
  function slugify(s) {
    return (s||'').toString().toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
  }

  function nowIso() { return new Date().toISOString(); }

  function setStatus(color, blinking=false) {
    statusCorner.style.backgroundColor = color;
    statusCorner.style.boxShadow = `0 0 10px ${color}`;
    statusCorner.style.animation = blinking ? 'blink 1s infinite alternate' : '';
  }

  function setSyncInfo(text) { syncInfo.textContent = text; }

  function saveEntriesToLocal() {
    try {
      localStorage.setItem(STORAGE_ENTRIES, JSON.stringify(entriesByCategory));
      setSyncInfo('Local saved: ' + (new Date()).toLocaleString());
    } catch (e) {
      console.warn('saveEntriesToLocal', e);
    }
  }

  function saveUnlockedToLocal() {
    // store as { category: [ids...] } for easy export / consumption
    const out = {};
    for (const cat of Object.keys(unlockedByCategory)) {
      out[cat] = Object.keys(unlockedByCategory[cat] || {}).filter(k => unlockedByCategory[cat][k]);
    }
    try {
      localStorage.setItem(STORAGE_UNLOCKED, JSON.stringify(out));
      setSyncInfo('Local saved: ' + (new Date()).toLocaleString());
    } catch (e) { console.warn('saveUnlockedToLocal', e); }
  }

  function loadEntriesFromLocal() {
    const raw = localStorage.getItem(STORAGE_ENTRIES);
    if (!raw) return false;
    try {
      entriesByCategory = JSON.parse(raw) || {};
      // ensure each category exists
      for (const c of categories) if (!entriesByCategory[c]) entriesByCategory[c] = [];
      return true;
    } catch (e) { console.warn('loadEntriesFromLocal', e); return false; }
  }

  function normalizeUnlockedData(raw) {
    unlockedByCategory = {};
    if (!raw) return;
    // raw might be {cat: [ids]} or {id:true,...} or an array of strings
    if (Array.isArray(raw)) {
      // list of ids, put them under 'global'
      unlockedByCategory.global = {};
      raw.forEach(s => unlockedByCategory.global[s] = true);
      return;
    }
    if (typeof raw === 'object') {
      // check if values are arrays (category -> array)
      const valuesAreArrays = Object.values(raw).every(v => Array.isArray(v));
      if (valuesAreArrays) {
        for (const [cat,arr] of Object.entries(raw)) {
          unlockedByCategory[cat] = {};
          arr.forEach(id => unlockedByCategory[cat][id] = true);
        }
      } else {
        // maybe a flat object of ids
        unlockedByCategory.global = {};
        for (const k of Object.keys(raw)) unlockedByCategory.global[k] = true;
      }
    }
  }

  function loadUnlockedFromLocal() {
    const raw = localStorage.getItem(STORAGE_UNLOCKED);
    if (!raw) return false;
    try {
      const parsed = JSON.parse(raw);
      normalizeUnlockedData(parsed);
      return true;
    } catch (e) { console.warn('loadUnlockedFromLocal', e); return false; }
  }

  function getEntryById(cat, id) {
    const arr = entriesByCategory[cat] || [];
    return arr.find(it => it.id === id) || null;
  }

  function ensureCategoryExists(cat) {
    if (!entriesByCategory[cat]) entriesByCategory[cat] = [];
    if (!unlockedByCategory[cat]) unlockedByCategory[cat] = {};
  }

  // --- initial default content (fallback) ---
  function seedDefaultsIfEmpty() {
    if (Object.keys(entriesByCategory).length !== categories.length) {
      entriesByCategory = {};
      for (const c of categories) entriesByCategory[c] = [];
    }
    // provide a small sample set only if truly empty
    if (!entriesByCategory.planets || entriesByCategory.planets.length === 0) {
      entriesByCategory.planets.push({ id:'tatooine', title:'Tatooine', content:'A desert world of twin suns and harsh dunes.' });
    }
    if (!entriesByCategory.characters || entriesByCategory.characters.length === 0) {
      entriesByCategory.characters.push({ id:'luke-skywalker', title:'Luke Skywalker', content:'A farmboy-turned-hero who became a symbol of the Rebellion.' });
    }
    for (const c of categories) ensureCategoryExists(c);
    saveEntriesToLocal();
  }

  // --- Rendering ---
  function renderBreadcrumbs(cat, entryId) {
    breadcrumbs.innerHTML = '';
    const home = document.createElement('span');
    home.textContent = 'Home';
    home.addEventListener('click', () => setActiveCategory(null));
    breadcrumbs.appendChild(home);
    if (cat) {
      const sep = document.createElement('span'); sep.textContent = '›'; breadcrumbs.appendChild(sep);
      const cspan = document.createElement('span');
      cspan.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
      cspan.addEventListener('click', () => setActiveCategory(cat));
      breadcrumbs.appendChild(cspan);
    }
    if (entryId) {
      const sep2 = document.createElement('span'); sep2.textContent = '›'; breadcrumbs.appendChild(sep2);
      const espan = document.createElement('span');
      const entry = getEntryById(cat, entryId);
      espan.textContent = entry ? entry.title : entryId;
      breadcrumbs.appendChild(espan);
    }
  }

  function renderCategoryList(cat) {
    activeCategory = cat;
    activeEntryId = null;
    renderBreadcrumbs(cat, null);
    // highlight active button
    categoryBtns.forEach(b => (b.dataset.category || null) === cat ? b.classList.add('active') : b.classList.remove('active'));
    homeBtn.classList.toggle('active', !cat);

    if (!cat) {
      entryContent.innerHTML = `<h1>Rebel Alliance Field Codex</h1><p>Entries are not loaded until a category is selected. Click a category on the left to begin.</p>`;
      return;
    }

    ensureCategoryExists(cat);
    const arr = entriesByCategory[cat] || [];
    // build list
    const container = document.createElement('div');
    if (arr.length === 0) {
      const emptyMsg = document.createElement('p');
      emptyMsg.textContent = 'No entries yet for this category.';
      emptyMsg.style.color = '#dff6ff';
      container.appendChild(emptyMsg);
    }

    arr.forEach(entry => {
      const row = document.createElement('div');
      row.className = 'entry-row';

      const titleBtn = document.createElement('button');
      titleBtn.className = 'entry-title';
      titleBtn.dataset.id = entry.id;
      titleBtn.textContent = entry.title || entry.id;

      // style classes for locked/unlocked/gm-locked
      const isUnlocked = unlockedByCategory[cat] && unlockedByCategory[cat][entry.id];
      if (entry.gmLocked) titleBtn.classList.add('gm-locked');
      else if (isUnlocked) titleBtn.classList.add('unlocked');
      else titleBtn.classList.add('locked');

      row.appendChild(titleBtn);

      // GM controls inline (edit/delete/unlock)
      if (isGM) {
        const unlockBtn = document.createElement('button');
        unlockBtn.className = 'unlock-btn';
        unlockBtn.textContent = isUnlocked ? 'Lock' : 'Unlock';
        unlockBtn.dataset.id = entry.id;
        unlockBtn.dataset.cat = cat;
        row.appendChild(unlockBtn);

        const editBtn = document.createElement('button');
        editBtn.className = 'gm-button';
        editBtn.textContent = 'Edit';
        editBtn.dataset.id = entry.id;
        editBtn.dataset.cat = cat;
        row.appendChild(editBtn);

        const delBtn = document.createElement('button');
        delBtn.className = 'gm-button remove';
        delBtn.textContent = 'Delete';
        delBtn.dataset.id = entry.id;
        delBtn.dataset.cat = cat;
        row.appendChild(delBtn);
      }

      container.appendChild(row);

      // ======== DYNAMIC JSON LOADER ========

// Holds all loaded entries by category
const entriesByCategory = {
  characters: [],
  factions: [],
  items: [],
  missions: [],
  planets: [],
  technology: []
};

// Holds unlocked entries (from unlocked.json)
let unlockedEntries = [];

// Utility to ensure category exists in entriesByCategory
function ensureCategoryExists(cat) {
  if (!entriesByCategory[cat]) entriesByCategory[cat] = [];
}

// Load unlocked entries
async function loadUnlockedEntries() {
  try {
    const resp = await fetch('entries/unlocked.json');
    if (!resp.ok) throw new Error('Failed to load unlocked.json');
    unlockedEntries = await resp.json(); // array of filenames like "luke_skywalker.json"
  } catch (err) {
    console.error('Error loading unlocked.json:', err);
    unlockedEntries = [];
  }
}

// Load all entries from manifests
async function loadEntriesFromManifests() {
  const categories = Object.keys(entriesByCategory);

  for (const cat of categories) {
    ensureCategoryExists(cat);

    try {
      const manifestResp = await fetch(`entries/${cat}/manifest.json`);
      if (!manifestResp.ok) {
        console.warn(`No manifest.json for category ${cat}`);
        continue;
      }

      const fileList = await manifestResp.json(); // e.g., ["luke_skywalker.json","mon_mothma.json"]
      for (const fileName of fileList) {
        // Only load if unlocked
        if (unlockedEntries.length > 0 && !unlockedEntries.includes(fileName)) continue;

        try {
          const entryResp = await fetch(`entries/${cat}/${fileName}`);
          if (!entryResp.ok) continue;
          const entryData = await entryResp.json();

          // Ensure entry has an ID
          if (!entryData.id) entryData.id = fileName.replace(/\.json$/, '');

          // Avoid duplicates
          if (!entriesByCategory[cat].some(e => e.id === entryData.id)) {
            entriesByCategory[cat].push(entryData);
          }
        } catch (err) {
          console.error(`Error loading entry ${fileName} from category ${cat}:`, err);
        }
      }
    } catch (err) {
      console.error(`Error fetching manifest for category ${cat}:`, err);
    }
  }

  // After all entries are loaded, you can trigger your existing code that populates UI
  if (typeof populateSidebar === 'function') populateSidebar(); // Example: refresh your sidebar buttons
  if (typeof renderEntries === 'function') renderEntries(); // Example: refresh main display
}

// Main initializer
document.addEventListener('DOMContentLoaded', async () => {
  await loadUnlockedEntries();
  await loadEntriesFromManifests();
});


    entryContent.innerHTML = '';
    const title = document.createElement('h1');
    title.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
    entryContent.appendChild(title);
    entryContent.appendChild(container);
  }

  function showEntryContent(cat, id) {
    const entry = getEntryById(cat, id);
    if (!entry) {
      entryContent.innerHTML = `<h1>Missing Entry</h1><p>Entry "${id}" not found.</p>`;
      return;
    }
    activeCategory = cat;
    activeEntryId = id;
    renderBreadcrumbs(cat, id);

    const el = document.createElement('div');
    const h = document.createElement('h1'); h.textContent = entry.title || id;
    el.appendChild(h);
    if (entry.image) {
      const img = document.createElement('img'); img.src = entry.image; img.alt = entry.title || '';
      el.appendChild(img);
    }
    const p = document.createElement('p'); p.textContent = entry.content || '';
    el.appendChild(p);

    // GM action buttons in content view
    if (isGM) {
      const row = document.createElement('div'); row.style.marginTop = '12px';
      const editBtn = document.createElement('button'); editBtn.className = 'gm-button'; editBtn.textContent = 'Edit Entry';
      editBtn.dataset.id = id; editBtn.dataset.cat = cat;
      const delBtn = document.createElement('button'); delBtn.className = 'gm-button remove'; delBtn.textContent = 'Delete Entry';
      delBtn.dataset.id = id; delBtn.dataset.cat = cat;
      const toggleBtn = document.createElement('button'); toggleBtn.className = 'unlock-btn'; 
      const isUnlocked = unlockedByCategory[cat] && unlockedByCategory[cat][id];
      toggleBtn.textContent = isUnlocked ? 'Lock' : 'Unlock';
      toggleBtn.dataset.id = id; toggleBtn.dataset.cat = cat;
      row.appendChild(editBtn); row.appendChild(delBtn); row.appendChild(toggleBtn);
      el.appendChild(row);
    }

    entryContent.innerHTML = '';
    entryContent.appendChild(el);
  }

  // --- Editor (add / edit) ---
  function showEditor(mode, cat, entry) {
    // require category
    if (!cat) { alert('Select a category first.'); return; }
    ensureCategoryExists(cat);

    // if already open, remove
    const existing = document.getElementById('gmEditor');
    if (existing) existing.remove();

    const box = document.createElement('div');
    box.id = 'gmEditor';
    box.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div style="color:#66f0ff;font-weight:700">${mode === 'add' ? 'Add New Entry' : 'Edit Entry'}</div>
        <div class="kv">Category: <strong>${cat}</strong></div>
      </div>
      <label>Title</label>
      <input type="text" id="editorTitle" />
      <div class="row">
        <div>
          <label>ID (optional — autogenerated if blank)</label>
          <input type="text" id="editorId" />
        </div>
        <div>
          <label>GM-Locked</label>
          <div style="margin-top:6px;">
            <input type="checkbox" id="editorGmLocked" /> <label for="editorGmLocked" style="display:inline;color:#bfeffb;"> Prevent normal players from seeing this entry</label>
          </div>
        </div>
      </div>
      <label>Image URL (optional)</label>
      <input type="text" id="editorImage" />
      <label>Content</label>
      <textarea id="editorContent" rows="7"></textarea>
      <div style="display:flex;gap:8px;margin-top:10px;justify-content:flex-end;">
        <button class="gm-button" id="editorSave">${mode === 'add' ? 'Create' : 'Save'}</button>
        <button class="gm-button remove" id="editorCancel">Cancel</button>
      </div>
    `;
    document.getElementById('main').appendChild(box);

    // populate if edit
    if (mode === 'edit' && entry) {
      document.getElementById('editorTitle').value = entry.title || '';
      document.getElementById('editorId').value = entry.id || '';
      document.getElementById('editorImage').value = entry.image || '';
      document.getElementById('editorContent').value = entry.content || '';
      document.getElementById('editorGmLocked').checked = !!entry.gmLocked;
    }

    // handlers
    document.getElementById('editorCancel').addEventListener('click', () => box.remove());
    document.getElementById('editorSave').addEventListener('click', () => {
      const title = document.getElementById('editorTitle').value.trim();
      let id = document.getElementById('editorId').value.trim();
      const image = document.getElementById('editorImage').value.trim();
      const content = document.getElementById('editorContent').value;
      const gmLocked = document.getElementById('editorGmLocked').checked;

      if (!title) { alert('Title required'); return; }

      if (!id) {
        id = slugify(title);
        // if collision, add timestamp
        const exists = getEntryById(cat, id);
        if (exists) id += '-' + Date.now().toString().slice(-4);
      } else {
        id = slugify(id);
      }

      if (mode === 'add') {
        // ensure id unique
        if (getEntryById(cat, id)) {
          alert('ID already exists — choose a different ID.');
          return;
        }
        entriesByCategory[cat].push({ id, title, image, content, gmLocked });
      } else {
        // edit: find and update
        const it = getEntryById(cat, entry.id);
        if (!it) {
          alert('Original entry not found.');
          box.remove();
          return;
        }
        // if id changed and collides:
        if (id !== entry.id && getEntryById(cat, id)) {
          alert('New ID collides with existing entry.');
          return;
        }
        it.id = id;
        it.title = title;
        it.image = image;
        it.content = content;
        it.gmLocked = gmLocked;
      }

      saveEntriesToLocal();
      box.remove();
      renderCategoryList(cat);
      showEntryContent(cat, id);
    });
  }

  // --- Actions: add / edit / delete / unlock ---
  function toggleUnlock(cat, id) {
    ensureCategoryExists(cat);
    unlockedByCategory[cat] = unlockedByCategory[cat] || {};
    const now = unlockedByCategory[cat][id];
    if (now) delete unlockedByCategory[cat][id];
    else unlockedByCategory[cat][id] = true;
    saveUnlockedToLocal();
    // refresh UI
    if (activeCategory === cat) renderCategoryList(cat);
    if (activeEntryId === id) showEntryContent(cat, id);
  }

  function deleteEntry(cat, id) {
    if (!confirm('Delete entry "' + id + '"? This cannot be undone locally.')) return;
    entriesByCategory[cat] = (entriesByCategory[cat] || []).filter(e => e.id !== id);
    // also remove unlocked flag
    if (unlockedByCategory[cat]) { delete unlockedByCategory[cat][id]; }
    saveEntriesToLocal();
    saveUnlockedToLocal();
    renderCategoryList(cat);
    entryContent.innerHTML = `<h1>Deleted</h1><p>Entry deleted.</p>`;
  }

  // --- export / copy / reset ---
  function exportUnlocked() {
    // convert to category -> array
    const out = {};
    for (const cat of Object.keys(unlockedByCategory)) {
      out[cat] = Object.keys(unlockedByCategory[cat] || {}).filter(k => unlockedByCategory[cat][k]);
    }
    const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'unlocked.json'; a.click();
    URL.revokeObjectURL(url);
  }

  async function copyUnlocked() {
    const out = {};
    for (const cat of Object.keys(unlockedByCategory)) {
      out[cat] = Object.keys(unlockedByCategory[cat] || {}).filter(k => unlockedByCategory[cat][k]);
    }
    const txt = JSON.stringify(out, null, 2);
    try {
      await navigator.clipboard.writeText(txt);
      alert('Unlocked JSON copied to clipboard.');
    } catch (e) {
      // fallback
      const ta = document.createElement('textarea'); ta.value = txt; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); ta.remove();
      alert('Copied to clipboard (fallback).');
    }
  }

  function resetLocalUnlocked() {
    if (!confirm('Reset local unlocked state? This will clear local unlocked.json state.')) return;
    unlockedByCategory = {};
    saveUnlockedToLocal();
    renderCategoryList(activeCategory);
    alert('Local unlocked state reset.');
  }

  // --- Event delegation for main content (entries list + content buttons) ---
  document.getElementById('main').addEventListener('click', (e) => {
    const t = e.target;
    if (t.matches('.entry-title')) {
      const id = t.dataset.id;
      if (!activeCategory) return;
      showEntryContent(activeCategory, id);
    } else if (t.matches('.unlock-btn')) {
      const id = t.dataset.id || t.getAttribute('data-id');
      const cat = t.dataset.cat || activeCategory;
      toggleUnlock(cat, id);
    } else if (t.matches('.gm-button') && t.textContent.trim() === 'Edit') {
      const id = t.dataset.id; const cat = t.dataset.cat;
      const entry = getEntryById(cat, id);
      showEditor('edit', cat, entry);
    } else if (t.matches('.gm-button.remove') || (t.matches('.gm-button') && t.textContent.trim() === 'Delete') ) {
      const id = t.dataset.id; const cat = t.dataset.cat;
      deleteEntry(cat, id);
    }
  });

  // header category buttons
  categoryBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const cat = btn.dataset.category || null;
      setActiveCategory(cat);
    });
  });

  function setActiveCategory(cat) {
    if (!cat) {
      activeCategory = null;
      renderCategoryList(null);
      return;
    }
    activeCategory = cat;
    renderCategoryList(cat);
  }

  // GM toggle
  document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'g') {
      isGM = !isGM;
      gmTools.style.display = isGM ? 'flex' : 'none';
      gmIndicator.classList.toggle('active', isGM);
      // re-render current category so inline GM buttons appear/disappear
      if (activeCategory) renderCategoryList(activeCategory);
      else renderCategoryList(null);
    }
  });

  // GM tool actions
  addEntryBtn.addEventListener('click', () => {
    if (!activeCategory) { alert('Select a category to add an entry into.'); return; }
    showEditor('add', activeCategory, null);
  });
  exportBtn.addEventListener('click', exportUnlocked);
  copyBtn.addEventListener('click', copyUnlocked);
  resetLocalBtn.addEventListener('click', resetLocalUnlocked);

  // cursor + distortion
  function placeCursorAt(x,y) {
    cursorDot.style.transform = `translate(${x}px,${y}px)`;
    distortion.style.setProperty('--x', `${x}px`);
    distortion.style.setProperty('--y', `${y}px`);
  }
  document.addEventListener('mousemove', e => placeCursorAt(e.clientX,e.clientY));
  document.addEventListener('touchmove', e => { const t = e.touches[0]; placeCursorAt(t.clientX,t.clientY); });
  document.addEventListener('touchstart', e => { const t = e.touches[0]; placeCursorAt(t.clientX,t.clientY); });

  // search (simple title filter)
  searchInput.addEventListener('input', (e) => {
    const q = e.target.value.trim().toLowerCase();
    if (!activeCategory) return;
    if (!q) { renderCategoryList(activeCategory); return; }
    const arr = (entriesByCategory[activeCategory] || []).filter(it => (it.title||'').toLowerCase().includes(q) || (it.id||'').toLowerCase().includes(q));
    // render results quickly
    entryContent.innerHTML = `<h1>Search results for "${q}"</h1>`;
    const container = document.createElement('div');
    if (arr.length === 0) {
      const p = document.createElement('p'); p.textContent = 'No matches.'; entryContent.appendChild(p); return;
    }
    arr.forEach(entry => {
      const row = document.createElement('div'); row.className = 'entry-row';
      const titleBtn = document.createElement('button'); titleBtn.className = 'entry-title'; titleBtn.dataset.id = entry.id; titleBtn.textContent = entry.title;
      row.appendChild(titleBtn);
      if (isGM) {
        const editBtn = document.createElement('button'); editBtn.className = 'gm-button'; editBtn.textContent = 'Edit'; editBtn.dataset.id = entry.id; editBtn.dataset.cat = activeCategory;
        row.appendChild(editBtn);
      }
      container.appendChild(row);
    });
    entryContent.appendChild(container);
  });

  // initial load: try read local storage; if missing seed defaults
  const hadEntries = loadEntriesFromLocal();
  const hadUnlocked = loadUnlockedFromLocal();
  if (!hadEntries) seedDefaultsIfEmpty();
  if (!hadUnlocked) unlockedByCategory = {}; // start clean

  // initial UI
  setStatus('#ff4444', false);
  setSyncInfo('Local only');
  renderCategoryList(null);

  // debug panel toggle (optional)
  // debugPanel.style.display = 'block';
});
</script>
</body>
</html>
